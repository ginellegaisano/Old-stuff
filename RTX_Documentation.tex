\documentclass[11pt, oneside]{article}
\usepackage{geometry}
\geometry{letterpaper}
\usepackage{graphicx}
\usepackage{amssymb,amsmath,parskip}
\usepackage{array}
\usepackage{longtable}

\newcommand{\tabitem}{~~\llap{\textbullet}~~}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}


\title{SE350 Operating Systems Documentation}
\author{Gaisano, G., Janecka, L., Mak, R., Schneider, C.}


\begin{document}
\maketitle

\section{Introduction}
Clarisse
\begin{itemize}
\item What is this document about
\item What is the purpose of the document?
\item What does the document contain?
\end{itemize}

\section{Global Variable Documentation}
Everyone
\begin{itemize}
\item What does each variable store?
\item Why is there a variable to store this?
\item What do your global data structures look like?
\item What functions use it?
\end{itemize}

{\bf Global Variables}
\begin{description}
\item [VARIABLE\_NAME] Stores x for y purpose, used by:
\begin{itemize}
\item z
\end{itemize}
\end{description}

{\bf Global Data Structures}
\begin{description}
\item [DATA\_STRUCTURE\_NAME] Stores x for y purpose, used by:
\newline
\begin{longtable}{|L{2cm}|L{5cm}|L{5cm}|} \hline
\textbf{Structure Name} & \textbf{Purpose} & \textbf{Properties} \\ \hline
Queue& generic queue &
\tabitem \textbf{Element *first}: pointer to first element in the Queue. Is NULL if there are no elements.
\newline
\tabitem \textbf{Element *last}: pointer to last element in the Queue. Is NULL if there are no elements.\\ \hline
Element & Generic queue element &
\tabitem \textbf{Element *next}: pointer to next element in queue. NULL if the last element
\newline
\tabitem \textbf{void *data}: pointer to element data
\newline
\tabitem \textbf{void *block}: pointer to memory block element resides in \\ \hline
PCB & \textbf{Process Control Block}. Used to store process identification data and status, such as running state and progress in process& \textbf{U32 *mp\_sp}: stack pointer of process \newline
\tabitem \textbf{U32 m\_pid}: process id \newline
\tabitem \textbf{PROC\_STATE\_E m\_state}: current running state of the process \newline
\tabitem \textbf{int m\_priority}: process priority (low value = high priority) \newline
\tabitem \textbf{Queue *mailbox}: pointer to the process' mailbox. Contains all messages passed to process. After initialization, remains unchanged, as only the first and last pointers change.\\ \hline
Block & Represents a chunk of free memory. Is returned to the user on request\_memory\_block &
\tabitem \textbf{int pid}: the id of the process that currently owns the Block. Is NULL if Block is free. \newline
\tabitem \textbf{Block *next}: pointer to the next Block in the free memory block list. Is NULL if block is in use/allocated to a user process. \\ \hline
msgbuf&Stores the message's data&
\tabitem \textbf{int mtype}: the message type (types defined in CONSTANTS section) \newline
\tabitem \textbf{char mtext[size]}: char array containing the message data. Size is dependent on BLOCK\_SIZE\\ \hline
Envelope&The header for a message. Contains necessary information for delivery. Is the structure that is passed around in the message-passing system.&
\tabitem \textbf{int sender\_id}: pid of sending process \newline
\tabitem \textbf{int destination\_id}: pid of destination process \newline
\tabitem \textbf{int time}: message timestamp \newline
\tabitem \textbf{int delay}: time delay to send message (seconds) \newline
\tabitem \textbf{msgbuf *message}: pointer to message data \newline
\\ \hline
\end{longtable}
\begin{itemize}
\item z
\end{itemize}
\end{description}

\section{Kernel API}
Clarisse
\begin{itemize}
\item All kernel fuctions
\item What does each function do?
\item What does proper use of this function look like?
\item What cleanup is necessary afterwards, if any?
\item Does my documentation cover its behaviour in all scenarios?
\item Is this described more efficiently through pseudo?
\end{itemize}

\section{Interrupts and their Handlers/Processes}
Ginelle

\paragraph{Global Variables:}
timed\_q

\paragraph{Major Design Changes}
\begin{itemize}
\item
Should made a special i-process queue instead of putting in them in the ready queue with other user processes
\item
Not have i-processes depend on message passing. Instead, have the i-process block itself on finishing with input and be unblocked by the interrupt handler.
\end{itemize}
\paragraph{Questions}
\begin{itemize}
\item What interrupts are enabled by your OS?
Interrupts:
\newline
\begin{tabular}{|L{2cm}|L{5cm}|L{5cm}|} \hline
 \textbf{Interrupt Handlers} & \textbf{Description} & \textbf{Functionality} \\ \hline
Timer &
Increments a counter after every clock tick. For each second passed, decrements all messages in the delayed timed queue.
&
\tabitem pushes delayed messages to appropriate destination process mailbox when message delay has passed.

\\ \hline
Keyboard & captures keyboard input, composes and sends a message to the UART i-process &

\tabitem prints debugging hot keys to UART1 output. \newline
\tabitem sends key press to KCD for command processing. \\ \hline
\end{tabular}

\begin{tabular}{|L{3cm}|L{4cm}|L{5cm}|} \hline
\textbf{i-process}& Description & Active \\ \hline
UART\_iprocess& blah & blah \\ \hline
KCD& blah & blah \\ \hline
\end{tabular}
\item \textbf{How does the OS handle those interrupts?} For the Timer Handler, once a message's delay had expired, the interrupt pushed the message to the mailbox of the destination process. All the logic for the timer-related interrupts are in the Timer Handler. For the Keyboard Handler, it sends a message to the UART i-process, who then sends that message to the KCD i-process for command decoding. While waiting for keyboard input, both i-processes are blocked on received, waiting for messages to arrive. All these processes are given the highest priority to ensure that they interrupt any current processes.

\item What do your interrupt processes do?
\item Does my documentation cover its behavior in all scenarios?
\item Is this described more efficiently through pseudo?
\end{itemize}

\section{System and User Processes}
RayMak
\begin{itemize}
\item What system processes are in the OS?
\item What is the purpose of each system process?
\item What does each system process do?
\item what services do each of the system processes depend on?
\item What system processes does each user processes use?
\end{itemize}

\section{Initialization}
The OS starts by initializing each of the interrupts (irq, timer, and uarts). Each of these are calls to given functions and were not implemented as part of this project and so will not be discussed in this report.

The OS then initializes the memory. This is done by setting the creating a pointer to the end of the available memory, \textbf{p\_end}. For each of the processes we move that pointer up by the size of a PCB to prevent them from being overwritten. A similar procedure is done for the ready, blocked on resource, blocked on received, and timed queues. The heap is now defined as starting at p\_end + 4 bits of buffer. The head end is defined as the end of available memory minus the amount of memory used for the stack of each process (RAM\_END\_ADDR - NUM\_PROCS - USR\_SZ\_STACK). At the start of this range the MSP is initialized, and within this range we create a Block with a null ownership pid and a next value pointing to the MSP. For each iteration we shift the MSP by BLOCK\_SIZE. This results in a heap of the appropriate bounds initialized as a linked list of BLOCK\_SIZE sized blocks.For more details view the associated section of 3.1.2.

Process initialization is done by building proc tables. The test processes are initialized using a \textbf{set\_test\_procs} function which builds a \textbf{g\_test\_procs} table with each of the test functions. Each function has default priority low and default stack size determined by a OS parameter \textbf{USR\_SZ\_STACK} We then set the starting values for A, B, and C to LOWEST. Finally each table entry is given a pointer to the corresponding function. When initializing all processes we call this set\_test\_procs function and iterate through the test table adding each entry to the \textbf{g\_proc\_table}. The rest of the functions are manually added since they have unique values. Most of these values are stored as global variables so that all functions have access to them. For more details view the associated section of 3.4.2

Parameters:
\begin{itemize}
    \item USR\_SZ\_STACK: the size of the stack allocated to each user process, this can be used to configure how much stack memory each process has access to
    \item RAM\_END\_ADDR: the ending address of available memory, this can be used to configure how much heap memory the OS has access (will be constrained by the hardware being used)
    \item BLOCK\_SIZE: the fixed size of each memory block, this can be used to configure the amount of memory given when request memory is called (can also be used to configure how many memory blocks to have)
\end{itemize}

\section{Testing}

\subsection{Test Handler}
Testing was done by creating a test handler that handled the set up, tear down, and printing of each test. The test handler was contained in \textit{usr\_proc.c} allowing test files to be separated and still use the handler. The test handler starts by printing the starting information, then it receives a message from each test and frees the memory used for that message. Once each of the five tests have finished the test handler is unblocked and it prints the ending information. A global variable is used to keep track of how many tests have failed to be printed.

\subsection{Test Procedure} Each test is initialized to LOW priority and the dummy test functions (A, B, and C) are initialized to LOWEST priority. When a test starts it sets its own priority and the property of any dummy tests that it uses to MEDIUM, this is done to ensure that only one test is running at a time in an isolated environment, ensuring that no tests interfere with each other. During its execution the test only messes with the priorities of the dummy test functions to keep this isolated state. Each test has a local variable \textbf{failed} which is used to count the number of internal assertions that have failed. Each test function also has a global counter (\textbf{function\_name\_count}) associated with it to allow assertions to be made between processes. When a test finishes it sets its priority to LOWEST and calls an endTest function. This function sends a message to the test handler, sets each of the dummy test functions and the test handler back to priority LOWEST, sets the global counters to 0, and checks the failed variable to print the correct output and update the global failed test counter. Essentially the endTest attempts to return everything to the same starting state and print the correct output at the end of each test.

\subsection{Part 1 Tests}
The part one tests focused on testing memory management and process priority switching (in \textit{usr\_proc1.c}).
\subsubsection{Test 1}
This test runs basic unit tests on getting and setting process priority. It starts with getting the priority of process A and checking that it is correct and that the appropriate ready queue contains A. It then tests preemption by setting process A to HIGH. Within A its global counter is incremented and the processor is released. This counter is checked to make sure that a did execute and return and the current priority of A is checked. This can also be con Finally the test attempts to set A to a invalid priority to ensure that an error is returned.
\subsubsection{Test 2}
This test runs basic unit tests on memory allocation and releasing. It starts by requesting a memory block and checking that the MSP has been updated appropriately. It then releases that memory block and checks that the MSP returns to the value it had initially. Next it checks the error codes by requesting a memory block, freeing it, then checking that the return value is RTX\_OK. The test then attempts to free the same memory block again and checks that the return value was RTX\_ERR.
\subsubsection{Test 3}
This test checks that memory ownership is enforced. It uses a global variable \textbf{test3\_mem} which is requested by test3. The test then sets B to MEDIUM and releases the processor. B then attempts to release test3\_mem, records the value in a global variable, and returns to test3. Test3 checks that B got a error when it attempted to release test3\_mem and releases it.
\subsubsection{Test 4}
This test checks what happens when we reach the end of memory. The test starts by requesting a bock of memory \textbf{test4\_mem}. This will be used later. The test then releases to C, Within test C we request exactly the number of free memory blocks +1. This should cause C to be blocked and the processor to switch back to test4. Here test4 checks that C has been put on the blocked on resource queue correctly. Then test4 releases the test4\_mem block which should trigger preemption back to C. Here C frees all of the memory that it allocated and returns to test4. Test4 checks that the amount of free memory blocks at the start of the test equals the amount of free memory at the end of the test to ensure that we have no memory leaks.
\subsubsection{Test 5}
This test focuses on ensuring that the way we manipulate our queues does not introduce memory leaks. We create generic queue elements containing two pointers (to the next element and to the data contained in the element). For efficiency we store multiple elements in a single memory block. Test5 starts by allocating enough elements to fill a memory block and checking that a new block has been allocated for them. It then released each of those elements and checks that the memory block allocated for them is returned correctly.

\subsection{Part 2 Tests}
The part two tests focused on testing message passing (in \textit{usr\_proc2.c}).

\textit{Note: the order of these tests seems a little odd, this is done to prevent tests from interfering with each other.}
\subsubsection{Test 1}
This test tests sending a receiving multiple messages. The test starts by sending a configurable number of messages to B (this value is stored in a variable NUM\_TEST\_MESSAGES\_MAILBOX) and checking that B's mailbox is of appropriate size. The test then switches to B who iterates through its mail box freeing each message, then returns to test1. This also tests that the special memory ownership related to message sending works since B is the one who releases the memory associated with the message.  This test can be used to evaluate the maximum number of messages the system can process at the same time.
\subsubsection{Test 2}
This test also tests sending and receiving multiple messages, but this test sends and receives one at a time instead of sending and receiving blocks of messages. The test records the number of free memory blocks then switches to B. Within a for loop of configurable size (stored in global variable NUM\_TEST\_MESSAGES) B creates a message, sends it, increments a counter (\textbf{messages\_sent}), and switches to test1. Within a similarly sized loop, test1 receives a message, deallocates it, increments a counter (\textbf{messages\_received}), and switches to B. Once the message sending is done we check that the ending number of free memory blocks is equal to the starting number of free memory blocks and that the number of messages sent is equal to the number of messages received. This ensures that there is no memory leak or lost messages. This test also runs the same procedure sending messages to itself. In theory this test can run for any number of messages.
\subsubsection{Test 3}
This test tests blocking and blocking from the blocked on receive queue. This test starts by immediately switching to C. C attempts to receive a message. It should be blocked and switch back to test3. Test3 checks that C is now on the blocked on receive queue then sends C a message and releases the processor. C should unblock, receive the message, increment a counter, and switch back to test3. Test3 checks the counter to make sure that C finished executing and checks that C has been removed from the blocked on receive queue.
\subsubsection{Test 4}
This test tests preemption on the blocked on receive queue. The test starts by setting A to HIGH priority which should preempt to A. A then attempts to receive a message and gets blocked with should preempt back to test4. Test 4 sends a message to A which should preempt back to A. A increments its counter and releases the processor. Then test4 just checks that A incremented its counter signifying that it finished running.
\subsubsection{Test 5}
This test contains the unit test for send, receive, and delayed send. The test starts by switching to A. A then sends two messages to test5, one with a delay and one without in that order (both messages contain different text to tell them apart), and releases the processor. Test5 now receives both messages. It checks that the sender was correctly sent and that the message text of the first message equal what we expect it to. It similarly checks that the text of the second message matches what should have been sent. This also ensures that the messages arrived in the correct order. Since the delayed message was sent first if it did not delay it would arrive first. We also watch the test to see that the test has the appropriate delay before printing.
\subsubsection{Manual Tests}
The Wall Clock was tested by manually entering each of the following commands after the automatic tests finished.

Manual tests:
\begin{itemize}
    \item \%W (wait a few seconds to watch it increment)
    \item \%WT
    \item \%W (wait a few seconds (check that the starting value is correct)
    \item \%WR (check that clock resets)
    \item \%WS 12:59:55 (watch to make sure it returns to 00:00:00)
    \item \%WS 33:00:00 (make sure that it does not set to invalid times)
    \item r (check that the ready queue is printed correctly)
    \item b (check that the blocked on resource queue is printed correctly)
    \item m (check that the blocked on receive queue is printed correctly)
    \item leave the wall clock running for a few minutes
\end{itemize}

\subsection{Part 3 Tests}
Part three is different from the other tests since it is implementing given pseudo code (in \textit{usr\_proc3.c}) with all other test process empty and uses a specialized test handler (in \textit{usr\_proc\_p3.c}). The automatic version of the test is simply the pseudo code listed in the assignment requirements.

Manual tests:
\begin{itemize}
     \item the above listed wall clock tests
     \item \%C 5 3 (move test4 to a new priority)
     \item r (check that test4 has changed priority)
     \item \%C 5 12 (check invalid priority)
     \item \%C 45 1 (check invalid process)
     \item \%C 10 3 (check forbidden processes)
     \item \%C 5 4 (check forbidden priority)
     \item \%C 8 0(check moving blocked processes)
 \end{itemize}

\subsection{Running the Tests} Tests were run automatically by the test handler (with the exceptions of the few listed manual tests). Each part's tests were contained in their own file separate from the test handler. To run a different set of tests we linked in that test file and ran it. Some exceptions were made for part 3 which required a different test handler due to its unique nature. Testing was done almost exclusively on the debugger, testing with the board only at the very end to make sure that the demo would run smoothly. This was done both to protect the board and allow us to the many tools built into the debugger.


\section{Major Design Changes}
Everyone
\begin{itemize}
\item What design decisions ended up being a mistake?
\item What were the major stumbling blocks?
\item What would you do differently if you started over?
\item What design issues did your OS have?
\end{itemize}

\section{Timing Analysis}
Everyone

\section{Conclusion}
Clarisse

\end{document}
