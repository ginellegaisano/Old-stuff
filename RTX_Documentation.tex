\documentclass[11pt, oneside]{article}
\usepackage{geometry}
\geometry{letterpaper}
\usepackage{graphicx}
\usepackage{amssymb,amsmath,parskip}

\title{SE350 Operating Systems Documentation}
\author{Gaisano, G., Janecka, L., Mak, R., Schneider, C.}


\begin{document}
\maketitle

\section{Introduction}
Clarisse
\begin{itemize}
\item What is this document about
\item What is the purpose of the document?
\item What does the document contain?
\end{itemize}

\section{Global Variable Documentation}
Everyone
\begin{itemize}
\item What does each variable store?
\item Why is there a variable to store this?
\item What do your global data structures look like?
\item What functions use it?
\end{itemize}

{\bf Global Variables}
\begin{description}
\item [VARIABLE\_NAME] Stores x for y purpose, used by:
\begin{itemize}
\item z
\end{itemize}
\end{description}

{\bf Global Data Structures}
\begin{description}
\item [DATA\_STRUCTURE\_NAME] Stores x for y purpose, used by:
\begin{itemize}
\item z
\end{itemize}
\end{description}

\clearpage
\section{Kernel API}
\subsection{Memory Management}
\subsubsection{Structure Overview}
Our memory scheme is initialized to create a linked list of Blocks, which have an int {\tt pid} value and Block pointer {\tt next}. We keep track of the head of the list with MSP, the memory stack pointer. We also have a linked list of Blocks which we partition and use to create Elements, which are handled within Queues and keep pointers to the Blocks containing relevant data.

The queue of Blocks holding Elements are removed completely from the set of possible memory Blocks that can be requested by processes, and may sometimes take another Block from the list of memory blocks when space is low, and return them when they no longer contain any Elements.

\subsubsection{Functions}
{\bf void memory\_init(void)}\\
Allocates memory for heap, links memory into blocks of size {\tt BLOCK\_SIZE}, and initializes all queues of all priority levels (blocked on resource, blocked on receive, ready, timer). It allocates memory for a mailbox Queue for each process, and initializes each queue's first and last pointers to null, before setting the appropriate gp\_pcbs's mailbox to the built mailbox.

It also initializes the ElementBlock pointer (i.e. the head of the blocks containing elements) by taking the first free block and decrementing the total number of memory blocks to work with. Afterwards, it sets the currElement pointer to the front of ElementBlock + the size of an int pointer (i.e. in the area of the Block we want to modify), and iterates through the block casting to type Element and setting $\rightarrow$next and $\rightarrow$data to null, and $\rightarrow$block to ElementBlock.

This should only be called once, from {\tt k\_rtx\_init.c}.


{\bf int getMSP()}\\
Returns the current address of MSP, i.e. the current memory stack pointer. This is only used for our first test suite, when we check to see if the MSP is the same before and after the request and subsequent release of a memory block.

The function should not need to be used in any other context, as the local MSP variable should only be accessed within its file, {\tt k\_memory.c}.

{\bf int getTotalFreeMemory()}\\
Returns the local variable free\_blocks, which keeps track of the number of free memory blocks. It is used in {\tt test2()} of {\tt user\_proc2.c}, which stress tests sending and receiving many messages and checks that the number of free memory blocks is the same before and after we allocate and deallocate all free memory.

The function should not need to be used in any other context, as the local MSP variable should only be accessed within its file, {\tt k\_memory.c}.

{\bf void *k\_request\_element(void)}\\
Returns a pointer to an Element within the chain of Element blocks (starting at ElementBlock) whose data is set to null, and is thus ready to be filled with a queue element.

Proper use is amounts to calling the method before something is added to a queue and setting its data pointer to the object you want to push into the queue. 

Cleanup requires calling {\tt k\_release\_element\_block()} on the pointer to the element.

Pseudo:
\begin{verbatim}
set currBlock to ElementBlock and currElement to the front of currBlock
while currElement->data is not null {
    if currElement is past the end of currBlock {
        if there is no block next in the chain of Element blocks {
            set currBlock->next to a new memory block (requested)
            decrement total_mem_blocks
            iterate over size of new memory block {
                set Element->next to null
                set Element->data to null
                set Element->block to the new 
                }
        }
        currBlock = currBlock->next
        set currElement to front of currBlock
    } else {
        increment currElement to the next Element in currBlock
    }
}
\end{verbatim}

{\bf int *k\_release\_element\_block(void *released)}\\
Returns a flag signalling {\tt RTX\_OK} or {\tt RTX\_ERR} after releasing the Element and checking if its block can be returned to the set of free memory blocks.

Proper use is amounts to calling the method after something is removed from a queue and only the contents are needed from now on, if at all.

Pseudo:
\begin{verbatim}
set Element->next to null
set Element->data to null
set elementBlock Element->block
set iterator to ElementBlock
set empty to true
disable irq
iterate over elementBlock {
    if the iterator's data is not null, set empty to false
}
if empty {
    while iterator->next is not null or elementBlock {
        set iterator to iterator->next
    }
    if iterator->next is elementBlock {
        set iterator->next to elementBlock->next
        put elementBlock back onto the list of free blocks
        increment total_em_blocks and free_blocks
    }
}
enable irq
return RTX_OK
\end{verbatim}


{\bf void *k\_request\_memory\_block(void)}\\
Returns a pointer to a Block that can be used to store variables of any type.

Proper use is amounts to calling the method before trying to construct any variable that will be used non-locally, and typecasting the pointer to the variable you're trying to construct.

Cleanup requires calling {\tt k\_release\_memory\_block()} on the pointer to the block.

Pseudo:
\begin{verbatim}
while there are no memory blocks or there are only 2 free_blocks and the current process pid is < 10 {
    set priority to the current priority
    push the current process element into blocked on resource queue for priority
    set current process state to blocked on resource
    enable irq
    release processor
}

disable irq
set a to current MSP
set MSP to MSP->next
set a->next to null
set a->pid to current process pid
decrement free_blocks
enable irq
return a
\end{verbatim}

{\bf int *k\_release\_memory\_block(void *p\_mem\_blk)}\\
Returns a flag signalling {\tt RTX\_OK} or {\tt RTX\_ERR} after releasing the block and checking if any processes can be unblocked on resource, and if the current process needs to be thusly preempted.

Proper use amounts to calling the method after a variable is no longer needed, and its memory can be thusly released and overwritten.

Pseudo:
\begin{verbatim}
set released to p_mem_block
set msg (of type msgbuf) to p_mem_blk
if released is null or released is not owned by the current process {
    return RTX_ERR
}
disable irq
set released->next to MSP
set released->pid to null
set MSP to released
increment free_blocks
enable irq

for each priority i {
    set element to popped element from the blockedResourceQ on i
    if element is not null {
        set pcb to the element's data
        set pcb->state to ready
        push element to ready q of priority i
        if the element priority is less than current priority {
            release processor
        }
    }
}
return RTX_OK
\end{verbatim}


\subsection{Queues}
\subsubsection{Structure Overview}
In {\tt queue.c}, we maintain a {\tt blocked\_resource\_qs} Queue pointer array, a {\tt blocked\_receive\_qs} Queue pointer array, and a {\tt ready\_qs} Queue pointer array, all of size {\tt NUM\_PRIORITIES}, as well as a {\tt timed\_q} Queue pointer array of size 1. Each Queue has a first and last Element pointer, which are initialized to null in {\tt memory\_init()}.

There are externed functions to pop, remove, push, and print any queue, as well as shortcut functions for the ready queue, which is frequently used.

\subsubsection{Functions}
{\bf Element* pop(Queue* self)}\\
Returns a pointer to the topmost element in a queue, and null if empty. Also manipulates the queue such that the topmost element is then shucked from the queue, and the queue's first (and possibly last) pointer is thusly updated.

Proper use amounts to calling the method when trying to get the first element in a queue, and an Element pointer is set to its return value. The return value should be checked to see if it's null (which is returned when the queue is empty) before proceeding.

This method is often used when finding processes to schedule. Cleanup may involve deallocating the memory used for the Element, if the returned element isn't being pushed to another queue. 

{\bf Element* removeFromQ(Queue* self, int id)}\\
Returns a pointer to an element in a queue with the specified id, and null if empty. Also manipulates the queue such that the element is then shucked from the queue, and its previous element's next pointer (and possibly the queue's first and last pointers) is thusly updated.

Proper use amounts to calling the method when trying to remove a very specific element, and an Element pointer is set to its return value. The return value should be checked to see if it's null (which is returned when the queue is empty or the element is not found) before proceeding.

This method is often used when priority is being changed on a specific process and it needs to be moved between prioritized queues of the same type (e.g. from {\tt blocked\_resource\_qs$[$2$]$} to {\tt blocked\_resource\_qs$[$4$]$}, or when a message is being received and we need to remove the receiving process from the appropriate blocked on receive queue, regardless of its position in the queue.
 
{\bf int push(Queue* self, Element* element)}\\
Returns a a flag signalling {\tt RTX\_OK} when pushing an element to a specified queue. Puts the element on the back of a queue and updates its last element's next pointer, the queue's last pointer, and possibly its first pointer if the queue was formerly empty.

Proper use amounts to calling the method, passing in an element which already exists or that has been successfully requested, with its data pointer set to the data you want to keep track of.


{\bf void printReadyQ(char* tag)}\\
Prints a ``Ready Q" label and the tag that has been passed in. Then, iterates through the ready queue of each priority, printing from the queue's first until the element iterator is null (i.e. reaches the end of the list).

Used as a hotkey mapping, and also for debugging purposes.

{\bf void printBlockedQ(char* tag)}\\
Prints a ``Blocked Q" label and the tag that has been passed in. Then, iterates through the blocked on resource queue of each priority, printing from the queue's first until the element iterator is null (i.e. reaches the end of the list).

Used as a hotkey mapping, and also for debugging purposes.

{\bf void printBlockedReceiveQ(char* tag)}\\
Prints a ``Blocked Received Q" label and the tag that has been passed in. Then, iterates through the blocked on receive queue of each priority, printing from the queue's first until the element iterator is null (i.e. reaches the end of the list).

Used as a hotkey mapping, and also for debugging purposes.

{\bf void pushToReadyQ(int priority, Element* element)}\\
Calls push on {\tt ready\_qs$[$priority$]$} with the specified element.

Used instead of calling {\tt getReadyQ()} and passing that into {\tt push()}.

{\bf Element* popFromReadyQ(int priority)}\\
Calls pop on {\tt ready\_qs$[$priority$]$} and returns the returned element.

Used instead of calling {\tt getReadyQ()} and passing that into {\tt pop()}.

{\bf Queue* getReadyQ(int priority)}\\
Returns a pointer to the Queue stored in {\tt ready\_qs$[$priority$]$}.

This is used in favour of a global {\tt ready\_qs} variable, which caused us when calling from other classes even when externed.

{\bf setReadyQ(int priority, Queue* q)}\\
Sets {\tt ready\_qs$[$priority$]$} to the q passed in.

Should only be used in {\tt memory\_init()}, when queues are allocated space and built.

{\bf Queue* getBlockedResourceQ(int priority)}\\
Returns a pointer to the Queue stored in {\tt blocked\_resource\_qs$[$priority$]$}.

This is used in favour of a global {\tt blocked\_resource\_qs} variable, which caused us when calling from other classes even when externed.

{\bf setBlockedResourceQ(int priority, Queue* q)}\\
Sets {\tt blocked\_resource\_qs$[$priority$]$} to the q passed in.

Should only be used in {\tt memory\_init()}, when queues are allocated space and built.

{\bf Queue* getBlockedReceiveQ(int priority)}\\
Returns a pointer to the Queue stored in {\tt blocked\_receive\_qs$[$priority$]$}.

This is used in favour of a global {\tt blocked\_receive\_qs} variable, which caused us when calling from other classes even when externed.

{\bf setBlockedReceiveQ(int priority, Queue* q)}\\
Sets {\tt blocked\_receive\_qs$[$priority$]$} to the q passed in.

Should only be used in {\tt memory\_init()}, when queues are allocated space and built.

{\bf Queue* getTimedQ(void)}\\
Returns a pointer to the Queue stored in {\tt timed\_q$[0]$}.

This is used in favour of a global {\tt timed\_qs} variable, which caused us when calling from other classes even when externed.

{\bf setTimedQ(int priority, Queue* q)}\\
Sets {\tt timed\_qs$[0]$} to the q passed in.

Should only be used in {\tt memory\_init()}, when queues are allocated space and built.

\subsection{Message Passing}
\subsubsection{Structure Overview}
Messages require that a message be explicitly allocated and sent by the process that wants to pass a message, and the message be explicitly received and deallocated by the receiving process.

Envelopes contain a sender\_id, a destination\_id, a time sent, a delay (which can be 0), and a msgbuf object, which contains a type and character array for the message. When the process allocates the message, it essentially builds the msgbuf object, and afterwards sends the message by passing in the msgbuf object it just created and other relevant parameters.

Each PCB contains a pointer to a mailbox queue, which is populated by elements with data pointers to envelopes. When a mailbox is empty and {\tt receive\_message()} is called, the process puts itself on the appropriate blocked on receive queue. At every clock interval, the timer queue is iterated over, decrementing the delay on each envelope and sending to the appropriate mailbox if the delay reaches zero.

\subsubsection{Functions}
{\bf void setMessageText(msgbuf* message, char *text, int length)}\\
Iterates over the entire message's text characters (120), setting every one to null, then iterates over it again for the length specified setting the message text at the iterator position to the character at the same position in the passed-in text array. Afterwards, sets the text character array to null.

Should only be used in {\tt allocate\_message()} within the same class.

{\bf int checkMessageText(msgbuf* message, char *text)}\\
Iterates over the entire message's text characters (120), comparing the character in message at the iterator position to the character at the same position in the passed-in text array. At any point, returns 0 if the characters don't match, and returns 1 at the end of the function.

Is used in user testing to make sure that the received message is the one expected by comparing the return value to 0.

{\bf Envelope *build\_envelope(int process\_id, msgbuf *message\_envelope, int delay)}\\
Packages a message into an envelope to be put in a mailbox, returning the built envelope. The function requesting a memory block for the envelope, setting the returned block's pid to the receiving process id, casting the returned memory block to an Envelope, and setting the appropriate fields (sender\_id as current process id, destination\_id as parameter process\_id, message as parameter message\_envelope, time as {\tt get\_time()}, and delay as parameter delay.

Should only be called by functions that send messages (i.e. {\tt k\_send\_message()} and {\tt k\_delayed\_send()}), which receives an envelope pointer to pass into {\tt build\_envelope()}.

After the envelope is returned, it should be pointed to by the element's data pointer, which is then put into a process's message queue or the timed queue.

{\bf int destroy\_envelope(Envelope *envelope)}\\
Returns {\tt RTX\_ERR} if the current process's pid doesn't match the envelope's destination id (i.e. the process doesn't have the right to destroy it), and otherwise returns the flag returned by calling {\tt k\_release\_memory\_block()} on the address of the envelope.

Should only be called from {\tt k\_receive\_message}, at which point the envelope is no longer required, only the message being passed in it.

{\bf msgbuf *k\_allocate\_message(int type, char *text, int length)}\\
Creates a message to be passed into send message by requesting a memory block and casting to type msgbuf, setting the type of the message to parameter type, calling {\tt set\_message\_text()} and passing in the appropriate parameters, and then returning the built message.

Should be called from any process that wants to build a message, before its return value (of type msgbuf) is passed into {\tt send\_message()}. When received, will have to deallocate the message by using {\tt k\_deallocate\_message()}.

{\bf int *k\_deallocate\_message(msgbuf *message)}\\
Sets each character in the text of the message to null, casts the message to a Block, sets its pid to the current pid, and then calls and returns the return value of {\tt k\_release\_memory\_block()} on the address of the message.

Should be called from any process that receives and interprets a message.

{\bf int push\_mailbox(Envelope *envelope)}\\
Returns a flag signalling {\tt RTX\_OK} or {\tt RTX\_ERR} after pushing an envelope onto a mailbox.

Should only be called by {\tt k\_send\_message()}, which builds an envelope and pushes it to the appropriate mailbox, or the timer IRQ handler, which can pop off elements with envelopes whose delays have expired and push it to the appropriate mailbox.

Pseudo:
\begin{verbatim}
sets element to k\_request\_element()
disable irq
sets process to the pcb corresponding to envelope->destination id
set mailbox to process->mailbox
set element->at a to envelope

push element to queue mailbox

if the state of the destination process is blocked on receive {
    set process state to ready
    set popped to removeFromQ(blocked q of process's priority, process's id)
    push popped to ready q of process's priority
    if the destination process's priority is less than the current priority {
        enable irq
        release processor
    }
}
enable irq
return RTX_OK
\end{verbatim}

{\bf Envelope *pop\_mailbox(int process\_id)}\\
Pops the first envelope from the mailbox of the process with id process\_id, releases the element block of the popped element, and returns the envelope.

Should only be called by receiving functions such as {\tt k\_receive\_message} when taking the front message off of a mailbox.

{\bf int k\_send\_message(int process\_id, void *message\_envelope)}\\
Returns a flag signalling {\tt RTX\_OK} or {\tt RTX\_ERR} when sending a message. The function starts by checking if the destination process id is valid (and returns RTX\_ERR if not). Then, it builds the envelope using the {\tt build\_envelope()} function and the pointer to the msgbuf passed in as message\_envelope. After checking if the built envelope is null (and returning RTX\_ERR if so), push the envelope to the mailbox with {\tt push\_mailbox()} and return RTX\_OK.

Should be called from any process that wants to build a message, after {\tt k\_allocate\_message()} has been called and the msgbuf built to be passed into this function.

{\bf void *k\_receive\_message(int *sender\_id)}\\
Receives a message and returns a void pointer to its address.

Should be called from any process that wants to receive a message, after {\tt k\_allocate\_message()} has been called and the msgbuf built to be passed into this function. Should be followed by a {\tt deallocate\_message()} on the address of the received message, after its contents have been read and/or used.

Pseudo:
\begin{verbatim}
set mailbox to the current process's mailbox
if the mailbox is empty {
    set process state to blocked on receive
    set priority to the current process's priority
    push current element to the blocked receive q at priority
    release processor
}
disable irq
set process to current process
set mailbox to current process's mailbox
set received to the return value of pop mailbox of current process
set message to received's message
set message's block's pid to current pid
destroy envelope at address of received
enable irq
return address of message
\end{verbatim}

{\bf int k\_delayed\_send(int process\_id, void *message\_envelope, int delay)}\\
Returns a flag signalling {\tt RTX\_OK} or {\tt RTX\_ERR} when sending a message with a delay. The function checks if the destination process id is valid and returns RTX\_ERR if not. It then builds an envelope using the process\_id, msgbuf, and delay passed in, requests an element, and sets the element's data pointer to the built envelope. If the envelope is null, it returns RTX\_ERR. If not, it pushes the element to the timed q and returns RTX\_OK.

Should be called from any process that wants to build a message, after {\tt k\_allocate\_message()} has been called and the msgbuf built to be passed into this function.

\subsection{Process Management}
\subsubsection{Structure Overview}


\subsubsection{Functions}
{\bf void process\_init()}\\
Sets the test procedures (by calling {\tt set\_test\_procs()} in {\tt user\_proc.c} which sets the mpf start program counter, priority, pid, and stack size of each test procedure), then uses the now-initialized {\tt g\_test\_procs} to set the pid, priority, stack size, and mpf start program counter of each process in {\tt g\_proc\_table} in addition to initializing the system procedures in {\tt g\_proc\_table}.

It then iterates through the procedures, building the PCB for each process by allocating stack size, initializing the PCB's pid, state, priority, and stack pointer, then requesting an element to contain a pointer to this newly-generated PCB and pushing to the appropriate ready queue.

This should only be called once, from {\tt k\_rtx\_init.c}.

{\bf Element* scheduler(void)}\\
Returns an Element containing the PCB of the next process that should be run. The function iterates through the ready queues of each priority level (starting at the highest priority), popping the top element. If the element popped is null, it goes to the next priority. Else, it checks if the current process is null (and if so, sets it to the pcb of the popped element), and then returns that element.

Should only be called by {\tt k\_release\_processor()}, which calls for the next process to be run and then directs to a process switch if necessary.

{\bf int process\_switch(Element *element)}\\
Returns a flag signalling {\tt RTX\_OK} or {\tt RTX\_ERR} when switching two processes. The function attempts to switch out the old pcb and run the new pcb. However, if the new pcb was null, it gets set back to the previous pcb.

Should only be called by {\tt k\_release\_processor()}, which schedules the next process to be run, tries to switch the processes, and handles the aftermath.

Pseudo:
\begin{verbatim}
set old pcb to element data
set state to current process state

if state is new {
    if the current process is not equal to old pcbs and the old pub's state isn't new {
        set old pcb's memory stack pointer to the current MSP
        if old pcb's state is blocked on resource or receive {
            set old pcb's state to ready
            push element to ready queue
        }
    }
    set current process state to run
    set msp to the current process's stack pointer
    rte
}
if state is ready {
    set old pcbs stack pointer to current MSP
    if old pcb's state is blocked on resource or receive {
        set old pcb's state to ready
        push element to ready queue
    }
    set current process's state to run
    set msp to current process's stack pointer
} else {
    set current process to old pcbs
    return RTX_ERR
}
return RTX_OK
\end{verbatim}

{\bf int k\_release\_processor(void)}\\
Returns a flag signalling {\tt RTX\_OK} or {\tt RTX\_ERR} when trying to release the processor.

Function sets pcb old and element old to the current pcb and element, then calls scheduler until it returns a non-null element, which the current element variable is set to and the current process variable updated accordingly.
If the current process is still null, it is reverted back to the old element and pcb, and returns RTX\_ERR.
Else if the old pcb is old, set the current process state to run, update the stack pointer, and rte.
Else, call {\tt process\_switch()} with the old element and return RTX\_OK.

This function should be called any time a process becomes blocked, preempted, or wishes to exit (e.g. in a lot of our user tests).

{\bf int k\_set\_process\_priority(int process\_id, int priority)}\\
Returns a flag signalling {\tt RTX\_OK} or {\tt RTX\_ERR} while trying to set the priority of a process.

The function checks if the process id and priority are valid, and returns RTX\_ERR if not. Then, if the process in question is in the ready or new state, it removes from the ready queue and pushes to the new priority ready queue. Else if it is blocked on resource or receive, it removes it from the appropriate queue and pushes it to the queue with the updated priority.

After, it checks if the current process is the one being altered and the new priority is lower than before, or if it is not the current process and the new priority is higher than the current process's priority, and sets a flag if either are true. After updating the priority, the processor is released if the flag is set to true. Return RTX\_OK.

This function can be called anywhere, and is specifically used for a hotkey mapping, the {\tt set\_priority\_process()} system process, and extensively in our user tests.

\section{Interrupts and their Handlers/Processes}
Ginelle
\begin{itemize}
\item What interrupts are enabled by yoru OS?
\item How does the OS handle those interrupts?
\item What do your interrupt processes do?
\item Does my documentation cover its behaviour in all scenarios?
\item Is this described more efficiently through pseudo?
\end{itemize}

\section{System and User Processes}
RayMak
\begin{itemize}
\item What system processes are in the OS?
\item What is the purpose of each system process?
\item Waht does each system process do?
\item what services do each of the system processes depend on?
\item What system processes does each user processes use?
\end{itemize}

\section{Initialization}
Lara
\begin{itemize}
\item What steps does your OS take to boot?
\item What parameters does your OS have?
\item How are these parameters tuned?
\end{itemize}

\section{Testing}
Lara
\begin{itemize}
\item How did you test your code?
\item Did you do unit testing?
\item What did your tests do?
\item Did you use the debugger?
\item Was your testing manual or automated?
\end{itemize}

\section{Major Design Changes}
Everyone
\begin{itemize}
\item What design decisions ended up being a mistake?
\item What were the major stumbling blocks?
\item What would you do differently if you started over?
\item What design issues did your OS have?
\end{itemize}

\section{Timing Analysis}
Everyone

\section{Conclusion}
Clarisse

\end{document}  
